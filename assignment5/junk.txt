#include "PlyModel.h"
#include "Arcball.h"
#include "SceneNode.h"
#include "View.h"
#include "Model.h"
#include "Controller.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
using namespace std;
void myReshape(int w, int h);
void myKeyBoard(unsigned char key,int x, int y);
void myMouse(int button, int state, int x, int y);
void myDisplay(void);
void specialKeys(int key,int x,int y);
void myMouseMotion(int x, int y) ;
void myIdle(void);


float SCREEN_WIDTH=650;
float SCREEN_HEIGHT=650;

 SceneNode * root;
 View * view;
 Model* model;
 Controller *controller;

Arcball arcball(SCREEN_WIDTH,SCREEN_HEIGHT,1.5);
bool arcball_on=false;
Vector eye_vector(2.5,2.5,2.5);

#define speed 200
int cnt=0,period=0,cam_toggle=0;
bool hooked=false;



void myKeyBoard(unsigned char key,int x,int y)
{

 switch(key)
 {
    case 27: exit(0);
             break;
    case 'c':
    case 'C': cam_toggle=(++cam_toggle)%3;

            break;

 }
}

int main(int argc, char *argv[]) {
        
    Model * model=new Model();
    root=model->createSceneGraph();
    root->printChildren();
    view=new View(SCREEN_WIDTH,SCREEN_HEIGHT);

    glutInit(&argc, argv);
    
    view->createWindow("SceneGraph");

    view->initialize();
    //register callbacks
    glutDisplayFunc(myDisplay);
    glutReshapeFunc(myReshape);
    glutKeyboardFunc(myKeyBoard);
    glutSpecialFunc(specialKeys);
    glutMouseFunc(myMouse);
    glutMotionFunc(myMouseMotion);
    glutIdleFunc(myIdle);

    glutMainLoop();

    return 0;
}

void myIdle(void) {
  
    /*srand(time(NULL));
    float x = ((rand()%1000+1)-500.0)/20000.0;
    float y = ((rand()%1000+1)-500.0)/20000.0;
    float z = ((rand()%1000+1)-500.0)/20000.0;
    float phi = ((rand()%1000+1)-500.0)/5000.0;
*/

    //root->rotateLocalTransformMatrix(0.01,glm::vec3(0,1,0));
    SceneNode * cube=root->getChildren()[2];
   // cube->rotateLocalTransformMatrix(0.05,glm::vec3(0,1,0));
    SceneNode * f16=root->getChildren()[5];
    //f16->translateLocalTransformMatrix(glm::vec3(x,y,z));
    //f16->rotateLocalTransformMatrix(phi,glm::vec3(1,0,0));
    //f16->rotateLocalTransformMatrix(0.08,glm::vec3(1,0,0));

    cnt++;
    if(cnt==speed)
        {   cnt=0;
            period=(++period)%4;
            switch(period){
            case 0:f16->rotateLocalTransformMatrix(+135,glm::vec3(0,1,0));
                    //f16->rotateLocalTransformMatrix(phi,glm::vec3(0,1,-1));
            break;
            case 1:
            break;
            case 2:f16->rotateLocalTransformMatrix(-135,glm::vec3(0,1,0));
                //f16->rotateLocalTransformMatrix(phi,glm::vec3(0,-1,1));
            break;
            case 3:
              if(hooked){
                    SceneNode * porsche=cube->getChildren()[3];
                    porsche=cube->detachChild(porsche);
                    porsche->initTransformationMatrix();
                    porsche->translateLocalTransformMatrix(glm::vec3(4.0,-4.5,-4.0));
                    root->attachChild(porsche);
                    
                }
                else{
                    SceneNode * porsche=root->getChildren()[3];
                    porsche=root->detachChild(porsche);
                    porsche->translateLocalTransformMatrix(glm::vec3(-4.0,6.0,4.5));
                    cube->attachChild(porsche);
                    
                }
                hooked=!hooked;
            break;

            }
            
        }
    
    switch(period){
        case 0:cube->translateLocalTransformMatrix(glm::vec3(-8.0/speed,0,0));
               f16->translateLocalTransformMatrix(glm::vec3(-4.0/speed,0,-4.0/speed));
        break;
        case 1:cube->translateLocalTransformMatrix(glm::vec3(0,0,-8.0/speed));
             f16->translateLocalTransformMatrix(glm::vec3(-4.0/speed,0,-4.0/speed));
        break;
        break;
        case 2:cube->translateLocalTransformMatrix(glm::vec3(+8.0/speed,0,0));
             f16->translateLocalTransformMatrix(glm::vec3(4.0/speed,0,4.0/speed));
        break;
        case 3:cube->translateLocalTransformMatrix(glm::vec3(0,0,+8.0/speed));
            f16->translateLocalTransformMatrix(glm::vec3(4.0/speed,0,4.0/speed));
        break;
    }
  glutPostRedisplay();
}
void myMouse(int button, int state, int x, int y) {

 if(state==GLUT_DOWN && button==GLUT_LEFT_BUTTON)
    {
        if(!cam_toggle){
        arcball_on = true;
        arcball.set_current_xy(x,y);
        arcball.set_last_xy(x,y);
        }
    }else {
        if(!cam_toggle)
        arcball_on = false;
    }
    glutPostRedisplay();
  
}
void myMouseMotion(int x, int y) {

    if (arcball_on && !cam_toggle) {  // if left button is pressed
        arcball.set_current_xy(x,y);
     }
     glMatrixMode(GL_MODELVIEW);

    //arcball->rotateModelvthMouse(dim);
     if(!cam_toggle)
    arcball.rotateCameravthMouse(2.0,&eye_vector);
    
    glutPostRedisplay();
  

}

void myDisplay() {

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glm::vec4 eye;
    glm::mat4 transform;
    glm::vec3 eye_;
    switch(cam_toggle)
    {   
    
    case 0 :    gluLookAt(eye_vector.x(),eye_vector.y(),eye_vector.z(),0,0,0,0,1,0);
                break;
    
    case 1 ://eye=glm::vec4(eye_vector.x(),eye_vector.y(),eye_vector.z(),1.0);
            eye=glm::vec4(2.5,2.5,2.5,1.0);
            transform=(root->getChildren()[5])->getGlobalTransform();
            //glm::mat4 transform=(root->getChildren()[2])->getLocalTransform();
            eye=transform*eye;
            eye_=glm::vec3(eye);
            gluLookAt(eye_.x/4.0,eye_.y/0.95,eye_.z/4.0,0,0,0 ,0,1,0);
            break;
    case 2 :eye=glm::vec4(2.5,2.5,2.5,1.0);
            //eye=glm::vec4(eye_vector.x(),eye_vector.y(),eye_vector.z(),1.0);
            //printf(root->getChildren()[2]->getChildren()[4]->getParent()->getName());
           // transform=root->getChildren()[2]->getChildren()[4]->getGlobalTransform();
            //transform=root->getChildren()[2]->getGlobalTransform();
            transform=root->getChildren()[2]->getGlobalTransform();
            eye=transform*eye;
            eye_=glm::vec3(eye);
            gluLookAt((eye_.x/6.0),eye_.y+2.5,(eye_.z/6.0),0,0.8,0,0,1,0);
            break;

    }
  
    root->draw();
    glFlush();
}

void myReshape(int w,int h)
{

    SCREEN_WIDTH=w;
    SCREEN_HEIGHT=h;

     glViewport(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(65,SCREEN_WIDTH/SCREEN_HEIGHT,1,20);


    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(2.5,2.5,2.5, 0,0,0 , 0,1,0);

    root->draw();
}

void specialKeys(int key,int x,int y)
{


}




